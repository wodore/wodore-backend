# Generated by Django 5.2.10 on 2026-01-12 14:04

import os
from pathlib import Path

from django.core.files import File
from django.db import migrations


def migrate_category_symbols_to_symbol_app(apps, schema_editor):
    """
    Migrate category symbols to Symbol app.

    Approach:
    1. Create Flaticon licenses (premium and free)
    2. For each unique SVG file found in assets/:
       - Create ONE Symbol instance
    3. Link categories to symbols via FK:
       - If category has its own SVG: link to that symbol
       - If no SVG: link to parent symbol or generic symbol
    4. Process parent categories first, then child categories
    """
    Category = apps.get_model("categories", "Category")
    Symbol = apps.get_model("symbols", "Symbol")
    License = apps.get_model("licenses", "License")

    # Create Flaticon licenses
    # Premium (no attribution required)
    license_premium = License.objects.filter(slug="flaticon_premium").order_by().first()
    if not license_premium:
        license_premium = License(
            slug="flaticon_premium",
            name="Flaticon Premium",
            fullname="Flaticon Premium License",
            link="https://www.flaticon.com/legal#nav-flaticon-agreement",
            attribution_required=False,
            no_commercial=False,
            is_active=True,
        )
        license_premium.save()
        print("Created Flaticon Premium license")

    # Free (attribution required)
    license_free = License.objects.filter(slug="flaticon_free").order_by().first()
    if not license_free:
        license_free = License(
            slug="flaticon_free",
            name="Flaticon Free License",
            fullname="Flaticon Free",
            link="https://www.flaticon.com/legal#nav-flaticon-agreement",
            attribution_required=True,
            no_commercial=False,
            is_active=True,
        )
        license_free.save()
        print("Created Flaticon Free license")

    # Use Premium license for the icons
    license = license_premium

    # Base path for category asset files
    base_path = Path(__file__).resolve().parent.parent / "assets"

    # Track created symbols by file path to avoid duplicates
    # Key: (file_path, style), Value: Symbol instance
    symbol_cache = {}

    def get_symbol_for_svg_file(svg_path, style):
        """
        Get or create a Symbol for a given SVG file path.
        Each unique SVG file creates only ONE Symbol.

        Returns: Symbol instance
        """
        # Use relative path from base_path as key
        rel_path = svg_path.relative_to(base_path)
        cache_key = (str(rel_path), style)

        # Check cache first
        if cache_key in symbol_cache:
            return symbol_cache[cache_key]

        # Generate slug from file path - JUST the symbol name, not parent!
        # Examples:
        # - terrain/detailed/peak.svg -> peak
        # - accommodation/simple/hut.svg -> hut
        # - accommodation/detailed/accommodation.svg -> accommodation (parent category)
        # - generic/detailed/generic.svg -> generic
        parts = list(rel_path.with_suffix('').parts)  # Remove .svg extension and convert to list

        # Remove the style folder (detailed/simple/mono) from the path
        # parts will be like ('terrain', 'detailed', 'peak') or ('generic', 'detailed', 'generic')
        # or ('accommodation', 'detailed', 'accommodation') for parent categories
        if len(parts) == 3 and parts[1] in ('detailed', 'simple', 'mono'):
            # It's a 3-part path: parent-style-child.svg
            # Use ONLY the child/symbol name (parts[2]), not the parent
            slug = parts[2]
        elif len(parts) == 2:
            # It's a parent category: parent-style.svg (shouldn't happen with our structure)
            slug = parts[0]
        else:
            # Fallback: use the last part that's not a style
            slug_parts = [p for p in parts if p not in ('detailed', 'simple', 'mono')]
            slug = slug_parts[-1] if slug_parts else 'unknown'

        # Check database for existing symbol with this slug and style
        existing = Symbol.objects.filter(slug=slug, style=style).first()
        if existing:
            symbol_cache[cache_key] = existing
            print(f"    Reusing existing symbol: {slug} ({style})")
            return existing

        # Create new symbol from this unique SVG file
        new_symbol = Symbol(
            slug=slug,
            style=style,
            search_text=slug,  # Just use slug, can be updated manually later
            license=license,
            is_active=True,
            review_status="approved",
        )

        # Read file from assets and save to Symbol
        with open(svg_path, "rb") as f:
            new_symbol.svg_file.save(
                svg_path.name,
                File(f),
                save=True,
            )
        print(f"    Created new symbol: {slug} ({style}) from {rel_path}")
        symbol_cache[cache_key] = new_symbol
        return new_symbol

    def get_symbol_path(category, style):
        """
        Get the path to a symbol file for a category and style.

        Priority:
        1. assets/{parent}/{style}/{slug}.svg (for child categories)
        2. assets/{parent}/{style}/{parent}.svg (fallback to parent symbol)
        3. assets/generic/{style}/generic.svg (ultimate fallback)

        Returns:
            Path to symbol file or None
        """
        if category.parent:
            parent_slug = category.parent.slug
            child_slug = category.slug
        else:
            parent_slug = category.slug
            child_slug = None

        # For child categories, try specific symbol first
        if child_slug:
            specific_path = base_path / parent_slug / style / f"{child_slug}.svg"
            if specific_path.exists():
                return specific_path

        # Fallback to parent symbol
        parent_path = base_path / parent_slug / style / f"{parent_slug}.svg"
        if parent_path.exists():
            return parent_path

        # Ultimate fallback to generic
        generic_path = base_path / "generic" / style / "generic.svg"
        if generic_path.exists():
            return generic_path

        return None

    # Process parent categories first, then child categories
    parents = Category.objects.filter(parent=None).order_by("slug")
    children = Category.objects.exclude(parent=None).order_by("parent_id", "slug")

    total_parents = parents.count()
    total_children = children.count()
    total = total_parents + total_children

    print(f"\nMigrating symbols for {total} categories ({total_parents} parents, {total_children} children)...")

    # Process parent categories
    print(f"\n=== Processing {total_parents} parent categories ===")
    for i, category in enumerate(parents, 1):
        print(f"\n[{i}/{total_parents}] Processing parent: {category.identifier}")

        for style in ["detailed", "simple", "mono"]:
            # Find the SVG file for this category (with fallbacks)
            svg_path = get_symbol_path(category, style)
            if svg_path:
                # Get or create symbol for this SVG file
                symbol = get_symbol_for_svg_file(svg_path, style)
                # Link category to this symbol
                setattr(category, f"symbol_{style}2", symbol)
            else:
                print(f"    WARNING: No symbol file found for {category.identifier} ({style})")

        category.save(update_fields=["symbol_detailed2", "symbol_simple2", "symbol_mono2"])

    # Process child categories
    print(f"\n=== Processing {total_children} child categories ===")
    for i, category in enumerate(children, 1):
        print(f"\n[{i}/{total_children}] Processing child: {category.identifier}")

        for style in ["detailed", "simple", "mono"]:
            # Find the SVG file for this category (with fallbacks)
            svg_path = get_symbol_path(category, style)
            if svg_path:
                # Get or create symbol for this SVG file
                symbol = get_symbol_for_svg_file(svg_path, style)
                # Link category to this symbol
                setattr(category, f"symbol_{style}2", symbol)
            else:
                print(f"    WARNING: No symbol file found for {category.identifier} ({style})")

        category.save(update_fields=["symbol_detailed2", "symbol_simple2", "symbol_mono2"])

    print(f"\n✓ Migration complete: {len(symbol_cache)} unique symbols created")


def reverse_migration(apps, schema_editor):
    """Clear symbol_X2 fields (keep old fields for safety)."""
    Category = apps.get_model("categories", "Category")
    Category.objects.all().update(
        symbol_detailed2=None,
        symbol_simple2=None,
        symbol_mono2=None,
    )
    print("✓ Reversed: Cleared all symbol_X2 fields")


class Migration(migrations.Migration):
    dependencies = [
        ("categories", "0008_category_symbol_detailed2_category_symbol_mono2_and_more"),
        ("symbols", "0001_initial"),
        ("licenses", "0001_initial"),
    ]

    operations = [
        migrations.RunPython(
            migrate_category_symbols_to_symbol_app,
            reverse_code=reverse_migration,
        ),
    ]

# Generated by Django 5.2.10 on 2026-01-08 11:23

from django.db import migrations


def migrate_huttypes_to_categories(apps, schema_editor):
    """
    Migrate HutType instances to Category model.

    Creates:
    1. Child categories for each HutType (preserving their IDs)
    2. Root 'accommodation' category (with ID = max(HutType.id) + 1)
    """
    Category = apps.get_model("categories", "Category")
    HutType = apps.get_model("huts", "HutType")

    # Get all HutTypes first to determine max ID
    hut_types = HutType.objects.all().order_by("level", "slug")

    if not hut_types.exists():
        print("✓ No HutTypes found, nothing to migrate")
        return

    # Find max HutType ID to avoid conflicts
    max_huttype_id = max(ht.id for ht in hut_types)
    accommodation_id = max_huttype_id + 1

    # Create root accommodation category with ID higher than any HutType
    accommodation, created = Category.objects.get_or_create(
        slug="accommodation",
        parent=None,
        defaults={
            "id": accommodation_id,
            "name": "Unterkunft",  # Default language (de)
            "description": "Arten von Unterkünften",  # Default language (de)
            "i18n": {
                "name_en": "Accommodation",
                "name_fr": "Hébergement",
                "name_it": "Alloggio",
                "description_en": "Types of mountain accommodations",
                "description_fr": "Types d'hébergements de montagne",
                "description_it": "Tipi di rifugi di montagna",
            },
            "order": 10,
            "is_active": True,
        },
    )

    if created:
        print(f"✓ Created root 'accommodation' category (id={accommodation.id})")
    else:
        print(f"✓ Root 'accommodation' category already exists (id={accommodation.id})")

    # Migrate each HutType - iterate through model instances to properly copy JSONFields
    hut_types = HutType.objects.all().order_by("level", "slug")
    migrated = 0
    skipped = 0

    for ht in hut_types:
        slug = ht.slug

        # Check if category already exists
        if Category.objects.filter(slug=slug, parent=accommodation).exists():
            print(f"  ⊘ Skipping {slug} (already exists)")
            skipped += 1
            continue

        # Copy i18n field directly - this is the correct way to copy JSONFields in migrations
        # modeltrans pattern: base field = default lang, i18n = {"name_en": "...", "name_de": "..."}
        i18n_data = ht.i18n if ht.i18n else {}

        # Create category from hut type
        category = Category.objects.create(
            id=ht.id,
            slug=slug,
            parent=accommodation,
            # Set base fields (default language = de)
            name=ht.name or "",
            description=ht.description or "",
            # Set i18n field (copy from HutType)
            i18n=i18n_data,
            order=ht.level,
            is_active=True,
            # Copy image paths
            symbol=ht.symbol.name if ht.symbol else "",
            symbol_simple=ht.symbol_simple.name if ht.symbol_simple else "",
            icon=ht.icon.name if ht.icon else "",
        )

        print(f"  ✓ Migrated {slug} → Category (id={category.id})")
        migrated += 1

    print(f"\nMigration summary:")
    print(f"  HutTypes found: {len(hut_types)}")
    print(f"  Categories created: {migrated}")
    print(f"  Categories skipped (already exist): {skipped}")

    # Update PostgreSQL sequence to avoid ID conflicts in future inserts
    # Set sequence to max(id) + 1
    if migrated > 0 or created:
        from django.db import connection
        with connection.cursor() as cursor:
            cursor.execute(
                "SELECT setval(pg_get_serial_sequence('categories_category', 'id'), "
                "(SELECT MAX(id) FROM categories_category));"
            )
        print(f"  ✓ Updated category ID sequence")


def reverse_migration(apps, schema_editor):
    """
    Reverse migration - restore categories back to HutType.

    This copies data from Category back to HutType if it doesn't already exist,
    then deletes the accommodation categories.
    """
    Category = apps.get_model("categories", "Category")
    HutType = apps.get_model("huts", "HutType")

    # Get accommodation root and its children
    accommodation = Category.objects.filter(slug="accommodation", parent=None).first()

    if not accommodation:
        print("✓ No accommodation category found, nothing to reverse")
        return

    # Restore each child category back to HutType
    restored = 0
    skipped = 0

    for category in accommodation.children.all().order_by("order", "slug"):
        # Check if HutType already exists
        if HutType.objects.filter(slug=category.slug).exists():
            print(f"  ⊘ Skipping {category.slug} (HutType already exists)")
            skipped += 1
            continue

        # Get category data using .values() to access all fields
        cat_data = Category.objects.filter(id=category.id).values().first()

        # Build i18n dict from Category (just copy the i18n field)
        i18n_data = cat_data.get('i18n') or {}

        # Restore HutType from category
        hut_type = HutType.objects.create(
            slug=cat_data['slug'],
            # Set base fields (default language)
            name=cat_data.get('name') or "",
            description=cat_data.get('description') or "",
            # Set i18n field (other languages)
            i18n=i18n_data,
            level=cat_data['order'],
            # Copy image paths
            symbol=cat_data['symbol'] or "",
            symbol_simple=cat_data['symbol_simple'] or "",
            icon=cat_data['icon'] or "",
        )

        print(f"  ✓ Restored Category {category.slug} → HutType (id={hut_type.id})")
        restored += 1

    # Now delete the categories
    deleted_count, _ = accommodation.delete()  # Cascade deletes children too

    print(f"\nReverse migration summary:")
    print(f"  HutTypes restored: {restored}")
    print(f"  HutTypes skipped (already exist): {skipped}")
    print(f"  Categories deleted: {deleted_count}")

    # Update HutType sequence after restoration
    if restored > 0:
        from django.db import connection
        with connection.cursor() as cursor:
            cursor.execute(
                "SELECT setval(pg_get_serial_sequence('huts_huttype', 'id'), "
                "(SELECT MAX(id) FROM huts_huttype));"
            )
        print(f"  ✓ Updated HutType ID sequence")


class Migration(migrations.Migration):

    dependencies = [
        ("categories", "0001_initial"),
        ("huts", "0050_add_name_gin_index"),  # Need HutType model before it's deleted in 0051
    ]

    operations = [
        migrations.RunPython(
            migrate_huttypes_to_categories,
            reverse_migration,
        ),
    ]
